#! /usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import print_function
import os
import glob
# import sconsutils
from SCons.Script import Environment, AddOption, GetOption

# this is where we'd define qsub commands
# sconsutils

# Set up SCons environment
environ = os.environ.copy()
env = Environment(ENV=environ)

# command line arguments
AddOption('--bcfs',
          dest='bcfs',
          type='string',
          metavar='<path>',
          help='path to directory containing 1KG bcf files')
bcf_dir = GetOption('bcfs')
AddOption('--batwa_vcfs',
          dest='batwa_vcfs',
          type='string',
          metavar='<path>',
          help='path to directory containing Batwa vcf files')
batwa_vcfs_dir = GetOption('batwa_vcfs')
AddOption('--ancs',
          dest='ancs',
          type='string',
          metavar='<path>',
          help='path to directory containing ancestral fasta files')
ancs_dir = GetOption('ancs')
AddOption('--kmer',
          dest='k',
          type='int',
          default=3,
          metavar='<int>',
          help='context window size for kSFS (default 3)')
k = GetOption('k')
AddOption('--sample_pops',
          dest='sample_pops',
          type='string',
          metavar='<path>',
          default=3,
          help='optional path to file populations for each sample (i.e. '
               'integrated_call_samples_v3.20130502.ALL.panel)')
sample_pops = GetOption('sample_pops')
AddOption('--pops',
          dest='pops',
          type='string',
          metavar='<pop1,pop2,...>',
          help='comma-separated list of populations or superpopulations')
pops = GetOption('pops').split(',')
AddOption('--phastcons',
          dest='phastcons',
          type='string',
          metavar='<path>',
          help='path to gzipped phastcons file (i.e. phastCons100way.txt.gz)')
phastcons = GetOption('phastcons')
AddOption('--repeats',
          dest='repeats',
          type='string',
          metavar='<path>',
          help='path to gzipped repeats file (i.e. nestedRepeats.txt.gz)')
repeats = GetOption('repeats')
AddOption('--strict_mask',
          dest='strict_mask',
          type='string',
          metavar='<path>',
          help='path to strict mask bed file')
strict_mask = GetOption('strict_mask')
AddOption('--sizes',
          dest='sizes',
          type='string',
          metavar='<path>',
          help='path to chromosome sizes (hg19.chrom.sizes.txt)')
sizes = GetOption('sizes')
AddOption('--track',
          dest='track',
          type='string',
          metavar='<path>',
          default=None,
          help='bed file for a genomic track to restrict to')
track = GetOption('track')
AddOption('--track_complement',
          dest='track_complement',
          action='store_true',
          metavar='<path>',
          default=False,
          help='use complement of track')
track_complement = GetOption('track_complement')
AddOption('--outdir',
          type='string',
          metavar="DIR",
          default='scons_output',
          help='directory in which to output results will be created if '
               'nonexistant (default "scons_output")')
outdir = GetOption('outdir')
AddOption('--mushi_cfg',
          type='string',
          metavar="PATH",
          help='path to mushi config file')
mushi_cfg = GetOption('mushi_cfg')

# parse the --jobs command line argument
n_jobs = GetOption('num_jobs')

# need this so scons -h runs without error
if bcf_dir is not None:
    # autosome sizes
    tgt = os.path.join(outdir, 'hg19.autosome.sizes.txt')
    src = sizes
    cmd = ('egrep "chr[0-9]*\\t" ${SOURCE} | cut -c4- | sort > ${TARGET}')
    autosome_sizes = env.Command(tgt, src, cmd)

    # mask for repeats (autosomes only)
    tgt = os.path.join(outdir, 'repeats.bed.gz')
    src = repeats
    cmd = ('python tobed.py ${SOURCE} | egrep "[0-9]*\\t" | bgzip > ${TARGET}')
    repeats = env.Command(tgt, src, cmd)

    # mask for conserved sites (autosomes only)
    tgt = os.path.join(outdir, 'conserved.bed.gz')
    src = phastcons
    cmd = ('python tobed.py ${SOURCE} | egrep "[0-9]*\\t" | bgzip > ${TARGET}')
    conserved = env.Command(tgt, src, cmd)

    # merge the above and complement (autosomes only)
    tgt = os.path.join(outdir, 'ncnr.bed.gz')
    src = [repeats, conserved, autosome_sizes]
    cmd = ('gzip -cd ${SOURCES[:2]} | egrep "^[0-9]*\\t"| sort -k1,1 -k2,2n '
           '| bedtools merge -i stdin'
           '| bedtools complement -i stdin -g ${SOURCES[2]}'
           '| bgzip > ${TARGET}')
    ncnr_mask = env.Command(tgt, src, cmd)

    # strict mask (no chr, autosomes only)
    tgt = os.path.join(outdir, 'strict.bed.gz')
    src = strict_mask
    cmd = ('egrep "chr[0-9]*\\t" ${SOURCE} | cut -c4- | cut -f1-3 '
           '| bgzip > ${TARGET}')
    strict_mask_nochr = env.Command(tgt, src, cmd)

    # full mask (sites to keep)
    mask_file = os.path.join(outdir, 'mask.bed.gz')
    tgt = [mask_file, mask_file + '.tbi']
    src = [ncnr_mask, strict_mask_nochr]
    cmd = ('gzip -cd ${SOURCES} | sort -k1,1 -k2,2n | bedtools merge -i stdin'
           '| bgzip > ${TARGETS[0]} && tabix -s 1 -b 2 -e 3 ${TARGETS[0]}')
    mask = env.Command(tgt, src, cmd)

    for idx, pop in enumerate(pops + ['Batwa']):
        pop_outdir = os.path.join(outdir, pop)
        if pop != 'Batwa':
            pop_list = env.Command([os.path.join(pop_outdir, pop + '.list')],
                                   sample_pops,
                                   f'grep {pop} ${{SOURCE}} | '
                                   f'cut -f1 > ${{TARGET}}')
        snps_context = []
        # masked chromosome sizes for mutation rate estimation
        if idx == 0:
            masked_sizes = []
        # loop over chromosome bcf files
        for chro in (str(chro_int) for chro_int in range(1, 23)):
            # get bcf for this chromosome
            # NOTE assumes chro is indicated by 2nd '.'-delimited field in bcf
            # file name
            if pop == 'Batwa':
                bcf = glob.glob(f'{batwa_vcfs_dir}/*chr{chro}.vcf.gz')
            else:
                bcf = glob.glob(f'{bcf_dir}/*chr{chro}.*.bcf')
            assert len(bcf) == 1
            bcf = bcf[0]

            # create snps file with columns CHROM POS REF ALT AC AN
            tgt = os.path.join(pop_outdir, f'snps.{chro}.tsv')
            cmd = 'bcftools view -T ${SOURCES[0]} '
            if pop == 'Batwa':
                src = [mask[0], bcf]
            else:
                src = [mask[0], bcf, pop_list]
                cmd += '-S ${SOURCES[2]} '
            cmd += '-g ^miss -m2 -M2 -v snps -c 1:minor -Ou -f PASS -U'
            cmd += ' ${SOURCES[1]} | '
            if track is not None:
                print("WARNING! track mask isn't accounted for in mask size!")
                comp_flag = '^' if track_complement else ''
                cmd += f'bcftools view -T {comp_flag}{track} | '
            cmd += 'bcftools query -f '
            cmd += '\'%CHROM\\t%POS\\t%REF\\t%ALT\\t%AC\\t%AN\\n\''
            cmd += '> ${TARGET}'
            snps = env.Command(tgt, src, cmd)

            # get ancestral alignment for this chromosome
            anc_fasta = glob.glob(f'{ancs_dir}/human_ancestor_{chro}.fa')
            assert len(anc_fasta) == 1
            anc_fasta = anc_fasta[0]

            # snps file with ancestral k-mer contexts
            tgt = os.path.join(pop_outdir, f'snps.{k}mer.{chro}.tsv')
            src = [anc_fasta, snps]
            cmd = f'python ancestor.py ${{SOURCES}} {k} > $TARGET'
            snps_context.append(env.Command(tgt, src, cmd))

            if idx == 0:
                tgt = os.path.join(outdir, f'masked_size.{chro}.tsv')
                src = [mask[0], anc_fasta]
                cmd = f'tabix ${{SOURCES[0]}} {chro}: > ${{TARGET}}.mask.tmp && '
                cmd += f'python masked_size.py ${{SOURCES[1]}} ${{TARGET}}.mask.tmp --k {k} '
                cmd += '> ${TARGET} && '
                cmd += 'rm ${TARGET}.mask.tmp'
                masked_sizes.append(env.Command(tgt, src, cmd))

        # compute k-SFS
        tgt = os.path.join(pop_outdir, f'{k}-SFS.tsv')
        cmd = 'python ksfs.py ${SOURCES} > $TARGET'
        ksfs = env.Command(tgt, snps_context, cmd)

        if idx == 0:
            # masked genome size for mutation rate estimation
            tgt = os.path.join(outdir, f'masked_size.tsv')
            cmd = "cat ${SOURCES} | awk '{sum+=$2} END {print sum}' > $TARGET"
            masked_size = env.Command(tgt, masked_sizes, cmd)
