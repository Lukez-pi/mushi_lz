#! /usr/bin/env python
# -*- coding: utf-8 -*-

import numpy as onp
import jax.numpy as np


def C(n: int) -> onp.ndarray:
    '''The C matrix defined in the text

    n: number of sampled haplotypes
    '''
    W1 = onp.zeros((n - 1, n - 1))
    W2 = onp.zeros((n - 1, n - 1))
    b = onp.arange(1, n - 1 + 1)
    # j = 2
    W1[:, 0] = 6 / (n + 1)
    W2[:, 0] = 0
    # j = 3
    W1[:, 1] = 10 * (5 * n - 6 * b - 4) / (n + 2) / (n + 1)
    W2[:, 1] = (20 * (n - 2)) / (n+1) / (n+2)
    for col in range(n - 3):
        # this cast is crucial for floating point precision
        j = onp.float64(col + 2)
        # procedurally generated by Zeilberger's algorithm in Mathematica
        W1[:, col + 2] = -((-((-1 + j)*(1 + j)**2*(3 + 2*j)*(j - n)*(4 + 2*j - 2*b*j + j**2 - b*j**2 + 4*n + 2*j*n + j**2*n)*W1[:, col]) - (-1 + 2*j)*(3 + 2*j)*(-4*j - 12*b*j - 4*b**2*j - 6*j**2 - 12*b*j**2 - 2*b**2*j**2 - 4*j**3 + 4*b**2*j**3 - 2*j**4 + 2*b**2*j**4 + 4*n + 2*j*n - 6*b*j*n + j**2*n - 9*b*j**2*n - 2*j**3*n - 6*b*j**3*n - j**4*n - 3*b*j**4*n + 4*n**2 + 6*j*n**2 + 7*j**2*n**2 + 2*j**3*n**2 + j**4*n**2)*W1[:, col + 1])/(j**2*(2 + j)*(-1 + 2*j)*(1 + j + n)*(3 + b + j**2 - b*j**2 + 3*n + j**2*n)))
        W2[:, col + 2] = ((-1 + j)*(1 + j)*(2 + j)*(3 + 2*j)*(j - n)*(1 + j - n)*(1 + j + n)*W2[:, col] + (-1 + 2*j)*(3 + 2*j)*(1 + j - n)*(j + n)*(2 - j - 2*b*j - j**2 - 2*b*j**2 + 2*n + j*n + j**2*n)*W2[:, col + 1])/((-1 + j)*j*(2 + j)*(-1 + 2*j)*(j - n)*(j + n)*(1 + j + n))

    return W1 - W2


def M(n: int, t: np.ndarray, y: np.ndarray) -> np.ndarray:
    '''The M matrix defined in the text

    t: time grid, starting at zero and ending at np.inf
    y: population size in each epoch
    '''
    # epoch durations
    s = np.diff(t)
    # we handle the final infinite epoch carefully to facilitate autograd
    u = np.exp(-s[:-1] / y[:-1])
    u = np.concatenate((np.array([1]), u, np.array([0])))

    binom_vec = np.arange(2, n + 1) * (np.arange(2, n + 1) - 1) / 2

    return np.exp(binom_vec[:, np.newaxis]
                  * np.cumsum(np.log(u[np.newaxis, :-1]), axis=1)
                  - np.log(binom_vec[:, np.newaxis])) \
        @ (np.eye(len(y), k=0) - np.eye(len(y), k=-1)) \
        @ np.diag(y)


def prf(Z: np.ndarray, X: np.ndarray, L: np.ndarray) -> np.float64:
    '''Poisson random field log-likelihood of history

    Z: mutation spectrum history matrix (μ.Z)
    X: k-SFS data
    L: model matrix
    '''
    Ξ = L @ Z
    ℓ = (X * np.log(Ξ) - Ξ).sum()
    return ℓ


def d_kl(Z: np.ndarray, X: np.ndarray, L: np.ndarray) -> np.float64:
    '''Kullback-Liebler divergence between normalized SFS and its
    expectation under history
    ignores constant term

    Z: mutation spectrum history matrix (μ.Z)
    X: k-SFS data
    L: model matrix
    '''
    X_normalized = X / X.sum(axis=0)
    Ξ = L @ Z
    Ξ_normalized = Ξ / Ξ.sum(axis=1, keepdims=True)
    d_kl = (-X_normalized * np.log(Ξ_normalized)).sum()
    return d_kl


def lsq(Z: np.ndarray, X: np.ndarray, L: np.ndarray) -> float:
    '''least-squares loss between SFS and its expectation under history

    Z: mutation spectrum history matrix (μ.Z)
    X: k-SFS data
    L: model matrix
    '''
    Ξ = L @ Z
    lsq = (1 / 2) * ((Ξ - X) ** 2).sum()
    return lsq
